/*
 * SSTV Decoder (RX) - Portable implementation
 *
 * Demodulation pipeline:
 *   1. FM demod: BPF → CIIRTANK (tone detection) → AGC
 *   2. Sync detect: CIIRTANK at 1200 Hz → state machine
 *   3. VIS decode: Sync interrupts → bit-by-bit accumulation
 *   4. Image buffer: Line accumulation → RGB24 output
 */

#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <stdio.h>

#include "sstv_decoder.h"
#include "dsp_filters.h"

/* === SYNC DETECTOR STATE MACHINE === */
typedef enum {
    SYNC_IDLE = 0,           /* Waiting for sync pulse */
    SYNC_DETECTED = 1,       /* Sync pulse in progress */
    SYNC_VIS_WAITING = 2,    /* VIS header expected */
    SYNC_VIS_DECODING = 3,   /* Decoding VIS bits */
    SYNC_DATA_WAIT = 4       /* Image data coming */
} sync_state_t;

/* === VIS DECODER === */
typedef struct {
    int bit_count;           /* 0-7 for 7-bit VIS, 0-15 for 16-bit */
    uint16_t data;           /* Accumulated bits */
    int is_16bit;            /* 1 if 16-bit VIS detected */
    int bit_timer;           /* Samples remaining in current bit (30ms per bit) */
    double mark_accum;       /* Accumulated mark energy during bit period */
    double space_accum;      /* Accumulated space energy during bit period */
    int sample_count;        /* Samples accumulated in bit period */
    int start_bit_samples;   /* Samples accumulated for VIS start bit detection */
    int start_bit_pending;   /* 1 if next bit is the VIS start bit */
    /* Buffered VIS decoding */
    double *mark_buf;        /* Mark energy buffer */
    double *space_buf;       /* Space energy buffer */
    int buf_size;            /* Buffer size in samples */
    int buf_pos;             /* Current buffer write position */
    int buffering;           /* 1 while buffering VIS window */
} vis_decoder_t;

/* === IMAGE BUFFER === */
typedef struct {
    uint8_t *pixels;         /* RGB24 or grayscale */
    int width, height;
    int bytes_per_pixel;     /* 1 for grayscale, 3 for RGB */
    int current_line;        /* Current line being filled */
    int current_col;         /* Current column in line */
} image_buffer_t;

/* === MAIN DECODER STRUCT === */
struct sstv_decoder_s {
    double sample_rate;
    sstv_mode_t mode_hint;
    sstv_mode_t detected_mode;       /* Mode from VIS decode */
    int vis_enabled;
    sstv_rx_status_t last_status;
    
    /* === STATE MACHINES === */
    vis_decoder_t vis;
    sync_state_t sync_state;
    
    /* === DSP FILTERS === */
    sstv_dsp::CIIRTANK iir_mark;    /* Mark tone (1100 Hz) */
    sstv_dsp::CIIRTANK iir_space;   /* Space tone (1300 Hz) */
    sstv_dsp::CIIRTANK iir_mark_alt;  /* Alt mark tone (1080 Hz) */
    sstv_dsp::CIIRTANK iir_space_alt; /* Alt space tone (1320 Hz) */
    sstv_dsp::CIIRTANK iir_sync;    /* Sync tone (1200 Hz) */
    sstv_dsp::CFIR2 bpf;             /* Bandpass 800-3000 Hz */
    
    /* === DEMOD STATE === */
    double prev_sample;              /* For simple HPF */
    double level_agc;                /* AGC gain */
    double freq_pll;                 /* PLL frequency estimate */
    double phase_accumulator;        /* Phase tracking */
    double total_energy_smooth;      /* Smoothed total energy for sync detection */
    double mark_energy_smooth;       /* Smoothed mark energy */
    double space_energy_smooth;      /* Smoothed space energy */
    
    /* === IMAGE BUFFER === */
    image_buffer_t image_buf;
    
    /* === SYNC TRACKING === */
    int sync_pulse_count;
    int sync_pulse_duration;
    double sync_energy;
    
    /* === DEBUGGING === */
    int debug_level;                 /* 0=off, 1=errors, 2=info, 3=verbose */
};

/* === VIS CODE MAPPING === */
typedef struct {
    uint8_t vis_code;        /* 8-bit VIS code */
    sstv_mode_t mode;        /* Corresponding SSTV mode */
} vis_map_entry_t;

/* VIS code to mode lookup table */
/* Codes match standard VIS values (LSB-first transmission) */
static const vis_map_entry_t VIS_CODE_MAP[] = {
    /* Standard VIS codes (7-bit + parity) */
    { 0x84, SSTV_R24 },         /* Robot 24 */
    { 0x88, SSTV_R36 },         /* Robot 36 */
    { 0x0C, SSTV_R72 },         /* Robot 72 */
    { 0x44, SSTV_AVT90 },       /* AVT 90 */
    { 0x3C, SSTV_SCOTTIE1 },    /* Scottie 1 */
    { 0xB8, SSTV_SCOTTIE2 },    /* Scottie 2 */
    { 0xCC, SSTV_SCOTTIEX },    /* Scottie DX */
    { 0xAC, SSTV_MARTIN1 },     /* Martin 1 */
    { 0x28, SSTV_MARTIN2 },     /* Martin 2 */
    { 0xB7, SSTV_SC2_180 },     /* SC2-180 */
    { 0x3F, SSTV_SC2_120 },     /* SC2-120 */
    { 0xBB, SSTV_SC2_60 },      /* SC2-60 */
    { 0xDD, SSTV_PD50 },        /* PD 50 */
    { 0x63, SSTV_PD90 },        /* PD 90 */
    { 0x5F, SSTV_PD120 },       /* PD 120 */
    { 0xE2, SSTV_PD160 },       /* PD 160 */
    { 0x60, SSTV_PD180 },       /* PD 180 */
    { 0xE1, SSTV_PD240 },       /* PD 240 */
    { 0xDE, SSTV_PD290 },       /* PD 290 */
    { 0x71, SSTV_P3 },          /* Pasokon P3 */
    { 0x72, SSTV_P5 },          /* Pasokon P5 */
    { 0xF3, SSTV_P7 },          /* Pasokon P7 */
    { 0x82, SSTV_BW8 },         /* Robot B/W 8 */
    { 0x86, SSTV_BW12 },        /* Robot B/W 12 */
    
    /* Extended VIS codes (16-bit, second byte after 0x23 prefix) */
    { 0x45, SSTV_MR73 },        /* Martin R73 (extended) */
    { 0x46, SSTV_MR90 },        /* Martin R90 (extended) */
    { 0x49, SSTV_MR115 },       /* Martin R115 (extended) */
    { 0x4A, SSTV_MR140 },       /* Martin R140 (extended) */
    { 0x4C, SSTV_MR175 },       /* Martin R175 (extended) */
    { 0x25, SSTV_MP73 },        /* Martin P73 (extended) */
    { 0x29, SSTV_MP115 },       /* Martin P115 (extended) */
    { 0x2A, SSTV_MP140 },       /* Martin P140 (extended) */
    { 0x2C, SSTV_MP175 },       /* Martin P175 (extended) */
    { 0x85, SSTV_ML180 },       /* Martin L180 (extended) */
    { 0x86, SSTV_ML240 },       /* Martin L240 (extended - note: same code as BW12, disambiguated by prefix) */
    { 0x89, SSTV_ML280 },       /* Martin L280 (extended) */
    { 0x8A, SSTV_ML320 },       /* Martin L320 (extended) */
    { 0x73, SSTV_MN73 },        /* Martin N73 (extended) */
    { 0x6E, SSTV_MN110 },       /* Martin N110 (extended) */
    { 0x8C, SSTV_MN140 },       /* Martin N140 (extended) */
    { 0x6A, SSTV_MC110 },       /* Martin C110 (extended) */
    { 0x8D, SSTV_MC140 },       /* Martin C140 (extended) */
    { 0x8E, SSTV_MC180 },       /* Martin C180 (extended) */
};

#define VIS_MAP_SIZE (sizeof(VIS_CODE_MAP) / sizeof(vis_map_entry_t))

/* Forward declarations */
static void decoder_reset_state(sstv_decoder_t *dec);
static void decoder_process_sample(sstv_decoder_t *dec, double sample);
static void decoder_update_sync(sstv_decoder_t *dec, double sync_energy);
static int decoder_check_vis_ready(sstv_decoder_t *dec, sstv_mode_t *mode_out);
static int decoder_try_vis_from_buffer(sstv_decoder_t *dec, sstv_mode_t *mode_out);
static int vis_parity_ok(uint8_t vis_code);
static sstv_mode_t vis_code_to_mode(uint8_t vis_code, int is_extended);

sstv_decoder_t* sstv_decoder_create(double sample_rate) {
    if (sample_rate <= 0.0) {
        return NULL;
    }
    sstv_decoder_t *dec = (sstv_decoder_t *)calloc(1, sizeof(sstv_decoder_t));
    if (!dec) {
        return NULL;
    }
    dec->sample_rate = sample_rate;
    dec->mode_hint = SSTV_MODE_COUNT; /* no hint */
    dec->detected_mode = SSTV_MODE_COUNT; /* no mode detected yet */
    dec->vis_enabled = 1;
    dec->last_status = SSTV_RX_NEED_MORE;
    dec->debug_level = 0;
    
        /* Allocate VIS buffers (store ~800ms of energies) */
        dec->vis.buf_size = (int)(0.800 * sample_rate);
        if (dec->vis.buf_size < 1) {
            dec->vis.buf_size = 1;
        }
        dec->vis.mark_buf = (double *)calloc((size_t)dec->vis.buf_size, sizeof(double));
        dec->vis.space_buf = (double *)calloc((size_t)dec->vis.buf_size, sizeof(double));
        dec->vis.buf_pos = 0;
        dec->vis.buffering = 0;
    
    /* Initialize DSP filters */
    /* Mark: 1100 Hz (VIS bit=1), BW=100 Hz - standard SSTV spec */
    dec->iir_mark.SetFreq(1100.0, sample_rate, 10.0);
    /* Space: 1300 Hz (VIS bit=0), BW=100 Hz - standard SSTV spec */
    dec->iir_space.SetFreq(1300.0, sample_rate, 10.0);
    /* Alt Mark: 1080 Hz (MMSSTV) */
    dec->iir_mark_alt.SetFreq(1080.0, sample_rate, 10.0);
    /* Alt Space: 1320 Hz (MMSSTV) */
    dec->iir_space_alt.SetFreq(1320.0, sample_rate, 10.0);
    /* Sync: 1200 Hz, BW=100 Hz (for sync/leader detection) */
    dec->iir_sync.SetFreq(1200.0, sample_rate, 10.0);
    
    /* BPF: Kaiser-windowed FIR, 800-3000 Hz bandpass, 51 taps */
    /* Note: Gain compensation for FIR filter attenuation */
    dec->bpf.Create(51, sstv_dsp::kFfBPF, sample_rate, 800.0, 3000.0, 50.0, 10.0);
    
    if (1) {
        fprintf(stderr, "[DECODER] Filter configuration (sample_rate=%.0f Hz):\n", sample_rate);
        fprintf(stderr, "  Mark (1100 Hz): BW=100 Hz\n");
        fprintf(stderr, "  Space (1300 Hz): BW=100 Hz\n");
        fprintf(stderr, "  Sync (1200 Hz): BW=100 Hz\n");
        fprintf(stderr, "  Alt Mark (1080 Hz): BW=80 Hz\n");
        fprintf(stderr, "  Alt Space (1320 Hz): BW=80 Hz\n");
        fprintf(stderr, "  BPF: 800-3000 Hz, 51 taps, Kaiser window (50 dB)\n");
    }
    
    /* Initialize state */
    decoder_reset_state(dec);
    
    return dec;
}


void sstv_decoder_free(sstv_decoder_t *dec) {
    if (dec) {
        if (dec->image_buf.pixels) {
            free(dec->image_buf.pixels);
        }
            if (dec->vis.mark_buf) {
                free(dec->vis.mark_buf);
            }
            if (dec->vis.space_buf) {
                free(dec->vis.space_buf);
            }
        free(dec);
    }
}

void sstv_decoder_reset(sstv_decoder_t *dec) {
    if (!dec) return;
    
    decoder_reset_state(dec);
    dec->mode_hint = SSTV_MODE_COUNT;
    dec->last_status = SSTV_RX_NEED_MORE;
}

/* === INTERNAL HELPERS === */

static void decoder_reset_state(sstv_decoder_t *dec) {
    if (!dec) return;
    
    /* Reset sync state machine */
    dec->sync_state = SYNC_IDLE;
    dec->sync_pulse_count = 0;
    dec->sync_pulse_duration = 0;
    dec->sync_energy = 0.0;
    
    /* Reset VIS decoder */
    dec->vis.bit_count = 0;
    dec->vis.data = 0;
    dec->vis.is_16bit = 0;
    dec->vis.bit_timer = 0;
    dec->vis.mark_accum = 0.0;
    dec->vis.space_accum = 0.0;
    dec->vis.sample_count = 0;
    dec->vis.start_bit_samples = 0;
    dec->vis.start_bit_pending = 0;
    dec->vis.buf_pos = 0;
    dec->vis.buffering = 0;
    dec->sync_state = SYNC_IDLE;
    
    /* Reset demod state */
    dec->prev_sample = 0.0;
    dec->level_agc = 1.0;
    dec->freq_pll = 0.0;
    dec->phase_accumulator = 0.0;
    
    /* Clear image buffer */
    if (dec->image_buf.pixels) {
        free(dec->image_buf.pixels);
        dec->image_buf.pixels = NULL;
    }
    dec->image_buf.width = 0;
    dec->image_buf.height = 0;
    dec->image_buf.current_line = 0;
    dec->image_buf.current_col = 0;
}

/**
 * Process a single audio sample through the demod pipeline
 * 
 * Flow:
 *   1. BPF (800-3000 Hz)
 *   2. CIIRTANK tone detectors (mark, space, sync)
 *   3. Sync detection
 *   4. VIS decoding (if enabled)
 */
static void decoder_process_sample(sstv_decoder_t *dec, double sample) {
    if (!dec) return;
    
    static int first_call = 1;
    if (first_call && dec->debug_level >= 2) {
        fprintf(stderr, "[DECODER] decoder_process_sample() called, sample_rate=%.0f\n", dec->sample_rate);
        first_call = 0;
    }
    
    /* Clip to prevent overflow */
    if (sample > 24576.0) sample = 24576.0;
    if (sample < -24576.0) sample = -24576.0;
    
    /* Simple HPF: difference from previous sample (removes DC) */
    double hpf_out = (sample - dec->prev_sample) * 0.5;
    dec->prev_sample = sample;
    
    /* BPF (800-3000 Hz bandpass) */
    double bpf_out = dec->bpf.Do(hpf_out);
    
    /* Tone detectors */
    double mark_out = dec->iir_mark.Do(bpf_out);
    double space_out = dec->iir_space.Do(bpf_out);
    double mark_out_alt = dec->iir_mark_alt.Do(bpf_out);
    double space_out_alt = dec->iir_space_alt.Do(bpf_out);
    double sync_out = dec->iir_sync.Do(bpf_out);
    
    /* Demod: instantaneous frequency from mark/space envelope */
    double mark_energy = fabs(mark_out);
    double space_energy = fabs(space_out);
    double mark_energy_alt = fabs(mark_out_alt);
    double space_energy_alt = fabs(space_out_alt);
    double sync_energy = fabs(sync_out);
    
    /* Select stronger VIS pair (standard vs MMSSTV tones) */
    double vis_mark_energy = mark_energy;
    double vis_space_energy = space_energy;
    int using_alt_tones = 0;
    if ((mark_energy_alt + space_energy_alt) > (mark_energy + space_energy)) {
        vis_mark_energy = mark_energy_alt;
        vis_space_energy = space_energy_alt;
        using_alt_tones = 1;
    }
    
    /* Debug: Log tone pair selection during VIS decode */
    static int tone_pair_log_counter = 0;
    if (dec->vis_enabled && (dec->sync_state == SYNC_VIS_WAITING || dec->sync_state == SYNC_VIS_DECODING) 
        && dec->debug_level >= 2 && (tone_pair_log_counter++ % 5000) == 0) {
        fprintf(stderr, "[VIS-TONEPAIR] Using %s: std=%.6f alt=%.6f ratio=%.3f\n",
                using_alt_tones ? "ALT(1080/1320)" : "STD(1100/1300)",
                (mark_energy + space_energy), (mark_energy_alt + space_energy_alt),
                (mark_energy + space_energy) > 0 ? (mark_energy_alt + space_energy_alt) / (mark_energy + space_energy) : 0.0);
    }
    
    /* For VIS leader detection, use total signal energy (leader is 1900 Hz, not 1200) */
    double total_energy = fabs(bpf_out);
    
    /* Smooth energies with simple IIR low-pass (50 Hz cutoff like MMSSTV) */
    /* For 50 Hz LPF: tau = 1/(2*pi*50) = 3.2ms, alpha ~ 1-exp(-dt/tau) */
    /* At 44100 Hz: dt=0.023ms, alpha ~ 0.007 */
    const double alpha = 0.15;  /* Faster smoothing for VIS tone detection */
    dec->total_energy_smooth = (1.0 - alpha) * dec->total_energy_smooth + alpha * total_energy;
    dec->mark_energy_smooth = (1.0 - alpha) * dec->mark_energy_smooth + alpha * mark_energy;
    dec->space_energy_smooth = (1.0 - alpha) * dec->space_energy_smooth + alpha * space_energy;
    
    /* Debug: trace energy levels */
    static int sample_counter = 0;
    if (dec->debug_level >= 2 && (sample_counter++ % 4800) == 0) {
        fprintf(stderr, "[DECODER] Raw Sample Energy Analysis:\n");
        fprintf(stderr, "  Input sample (scaled): %.6f\n", sample);
        fprintf(stderr, "  HPF output: %.6f\n", hpf_out);
        fprintf(stderr, "  BPF output: %.6f\n", bpf_out);
        fprintf(stderr, "  Mark tone (1100Hz): %.6f (energy=%.6f)\n", mark_out, mark_energy);
        fprintf(stderr, "  Space tone (1300Hz): %.6f (energy=%.6f)\n", space_out, space_energy);
        fprintf(stderr, "  Sync tone (1200Hz): %.6f (energy=%.6f)\n", sync_out, sync_energy);
        fprintf(stderr, "  Total smoothed: %.6f\n", dec->total_energy_smooth);
    }
    
    /* AGC: track level for normalization */
    if (mark_energy > 0.0 || space_energy > 0.0) {
        double total_energy = mark_energy + space_energy;
        if (total_energy > 0.0) {
            dec->level_agc = 0.99 * dec->level_agc + 0.01 * (1.0 / total_energy);
        }
    }
    
    /* Sync detection - use smoothed total energy for leader, sync_energy for breaks */
    if (dec->sync_state == SYNC_IDLE || dec->sync_state == SYNC_DETECTED) {
        /* Look for 1900 Hz leader or 1200 Hz break using smoothed broadband energy */
        if (dec->debug_level >= 3 && dec->total_energy_smooth > 0.01) {
            static int log_count = 0;
            if ((log_count++ % 1000) == 0) {
                fprintf(stderr, "[DECODER] Sync check: total_smooth=%.4f thresh=0.02 sync_state=%d\n",
                        dec->total_energy_smooth, dec->sync_state);
            }
        }
        decoder_update_sync(dec, dec->total_energy_smooth);
    } else {
        /* During VIS decode, use sync filter */
        decoder_update_sync(dec, sync_energy);
    }
    
    /* VIS start bit detection (transition from WAITING → DECODING) */
    if (dec->vis_enabled && dec->sync_state == SYNC_VIS_WAITING) {
        if (dec->vis.buffering && dec->vis.mark_buf && dec->vis.space_buf) {
            if (dec->vis.buf_pos < dec->vis.buf_size) {
                dec->vis.mark_buf[dec->vis.buf_pos] = vis_mark_energy;
                dec->vis.space_buf[dec->vis.buf_pos] = vis_space_energy;
                dec->vis.buf_pos++;
            }

            if (dec->vis.buf_pos >= dec->vis.buf_size) {
                sstv_mode_t detected_mode;
                if (decoder_try_vis_from_buffer(dec, &detected_mode)) {
                    (void)decoder_check_vis_ready(dec, &detected_mode);
                    dec->vis.buffering = 0;
                    return;
                }
                dec->vis.buffering = 0;
            }
        }

        /* Align to 1200 Hz start bit: detect rise, then start decoding on fall */
        const int MIN_WAIT = (int)(0.020 * dec->sample_rate);   /* 20ms guard */
        const int MAX_WAIT = (int)(0.200 * dec->sample_rate);   /* 200ms timeout */
        const int STARTBIT_MAX = (int)(0.040 * dec->sample_rate); /* 40ms max start bit */

        dec->vis.start_bit_samples++;

        if (dec->vis.start_bit_samples < MIN_WAIT) {
            /* Guard period after leader detection */
        } else if (!dec->vis.start_bit_pending) {
            /* Look for 1200 Hz start bit to begin */
            if (sync_energy > dec->total_energy_smooth * 0.2) {
                dec->vis.start_bit_pending = 1;
                dec->vis.start_bit_samples = 0;
                if (dec->debug_level >= 3) {
                    fprintf(stderr, "[DECODER] VIS start bit detected (sync rise)\n");
                }
            } else if (dec->vis.start_bit_samples >= MAX_WAIT) {
                /* Timeout - start anyway */
                dec->sync_state = SYNC_VIS_DECODING;
                dec->vis.bit_count = 0;
                dec->vis.data = 0;
                dec->vis.bit_timer = 0;
                dec->vis.mark_accum = 0.0;
                dec->vis.space_accum = 0.0;
                dec->vis.sample_count = 0;
                dec->vis.start_bit_samples = 0;
                dec->vis.start_bit_pending = 0;
                dec->vis.buffering = 1;
                dec->vis.buf_pos = 0;
                if (dec->debug_level >= 2) {
                    fprintf(stderr, "[DECODER] VIS data window, beginning decode (timeout after %dms)\n",
                            (int)(MAX_WAIT * 1000 / dec->sample_rate));
                }
            }
        } else {
            /* Start bit in progress; wait for it to end */
            if (sync_energy < dec->total_energy_smooth * 0.25 || dec->vis.start_bit_samples >= STARTBIT_MAX) {
                dec->sync_state = SYNC_VIS_DECODING;
                dec->vis.bit_count = 0;
                dec->vis.data = 0;
                dec->vis.bit_timer = 0;
                dec->vis.mark_accum = 0.0;
                dec->vis.space_accum = 0.0;
                dec->vis.sample_count = 0;
                dec->vis.start_bit_samples = 0;
                dec->vis.start_bit_pending = 0;
                dec->vis.buffering = 1;
                dec->vis.buf_pos = 0;
                if (dec->debug_level >= 2) {
                    fprintf(stderr, "[DECODER] VIS data window, beginning decode (start bit end)\n");
                }
            }
        }
    }
    
    /* VIS bit accumulation (if in VIS mode) */
    if (dec->vis_enabled && dec->sync_state == SYNC_VIS_DECODING) {
        if (dec->vis.buffering) {
            if (dec->vis.buf_pos < dec->vis.buf_size) {
                dec->vis.mark_buf[dec->vis.buf_pos] = vis_mark_energy;
                dec->vis.space_buf[dec->vis.buf_pos] = vis_space_energy;
                dec->vis.buf_pos++;
            }

            const int required_samples = (int)(0.030 * dec->sample_rate) * 8;
            if (dec->vis.buf_pos >= required_samples) {
                sstv_mode_t detected_mode;
                if (decoder_try_vis_from_buffer(dec, &detected_mode)) {
                    (void)decoder_check_vis_ready(dec, &detected_mode);
                }
                dec->vis.buffering = 0;
            }
            return;
        }

        /* Accumulate raw energy values over the bit period */
        dec->vis.mark_accum += vis_mark_energy;
        dec->vis.space_accum += vis_space_energy;
        dec->vis.sample_count++;
        dec->vis.bit_timer--;
        
        /* Debug: Log energies every 500 samples during VIS decode */
        static int vis_log_counter = 0;
        if (dec->debug_level >= 3 && (vis_log_counter++ % 500) == 0) {
            fprintf(stderr, "[VIS] timer=%d mark_smooth=%.4f space_smooth=%.4f mark_raw=%.4f space_raw=%.4f\n",
                    dec->vis.bit_timer, dec->mark_energy_smooth, dec->space_energy_smooth, mark_energy, space_energy);
        }
        
        /* When bit period expires, make decision using current sample */
        if (dec->vis.bit_timer <= 0) {
            /* Use smoothed energy values (MMSSTV's envelope detector) */
            double current_mark = dec->vis.mark_accum;
            double current_space = dec->vis.space_accum;
            if (dec->vis.sample_count > 0) {
                current_mark /= dec->vis.sample_count;
                current_space /= dec->vis.sample_count;
            }
            
            /* Bit decision: mark (1100 Hz) = 1, space (1300 Hz) = 0 */
            int bit = (current_mark > current_space) ? 1 : 0;
            
            if (dec->vis.start_bit_pending) {
                /* Discard start bit */
                dec->vis.start_bit_pending = 0;
            } else {
                /* MSB-first accumulation (like MMSSTV): shift right, then set bit 7 */
                dec->vis.data >>= 1;
                if (bit) {
                    dec->vis.data |= 0x80;
                }
                dec->vis.bit_count++;
            }
            
            if (dec->debug_level >= 3) {
                fprintf(stderr, "[DECODER] VIS bit %d: %d (mark=%.3f, space=%.3f)\n",
                        dec->vis.bit_count - 1, bit, current_mark, current_space);
            }
            
            /* Reset for next bit (30ms per VIS bit) */
            dec->vis.bit_timer = (int)(0.030 * dec->sample_rate);
            dec->vis.mark_accum = 0.0;
            dec->vis.space_accum = 0.0;
            dec->vis.sample_count = 0;
            
            /* Check if VIS decode is complete */
            sstv_mode_t detected_mode;
            if (decoder_check_vis_ready(dec, &detected_mode)) {
                if (dec->debug_level >= 2) {
                    fprintf(stderr, "[DECODER] VIS decode complete, mode=%d\n", detected_mode);
                }
            }
        }
    }
}

/**
 * Update sync state machine based on sync tone energy
 */
static void decoder_update_sync(sstv_decoder_t *dec, double sync_energy) {
    if (!dec) return;
    
    /* Sync pulse threshold (empirically tuned) */
    const double SYNC_THRESHOLD = 0.02;  /* Lower threshold for better sensitivity */
    const int SYNC_MIN_DURATION = (int)(0.070 * dec->sample_rate);  /* 5ms minimum */
    const int SYNC_MAX_DURATION = (int)(0.350 * dec->sample_rate);  /* 350ms max (leader is ~300ms) */
    
    if (sync_energy > SYNC_THRESHOLD) {
        /* In sync pulse */
        dec->sync_pulse_duration++;
        dec->sync_energy += sync_energy;
        
        if (dec->sync_state == SYNC_IDLE && dec->sync_pulse_duration >= SYNC_MIN_DURATION) {
            dec->sync_state = SYNC_DETECTED;
            dec->sync_pulse_count++;
            if (dec->debug_level >= 2) {
                fprintf(stderr, "[DECODER] Sync pulse detected (count=%d, duration=%d samples)\n",
                        dec->sync_pulse_count, dec->sync_pulse_duration);
            }
        }
        
        /* Auto-transition after long pulse (VIS leader) */
        if (dec->sync_state == SYNC_DETECTED && dec->sync_pulse_duration >= SYNC_MAX_DURATION) {
            if (dec->sync_pulse_count == 1 && dec->vis_enabled) {
                dec->sync_state = SYNC_VIS_WAITING;
                dec->vis.bit_count = 0;
                dec->vis.data = 0;
                dec->vis.start_bit_samples = 0;
                dec->vis.start_bit_pending = 0;
                dec->vis.buffering = 1;
                dec->vis.buf_pos = 0;
                if (dec->debug_level >= 2) {
                    fprintf(stderr, "[DECODER] Long sync pulse (leader), entering VIS_WAITING state\n");
                }
            }
            dec->sync_pulse_duration = 0;  /* Reset for next detection */
        }
    } else {
        /* Out of sync pulse */
        if (dec->sync_state == SYNC_DETECTED) {
            /* End of sync pulse */
            if (dec->sync_pulse_count == 1 && dec->vis_enabled) {
                /* First sync → VIS header coming */
                dec->sync_state = SYNC_VIS_WAITING;
                dec->vis.bit_count = 0;
                dec->vis.data = 0;
                dec->vis.start_bit_samples = 0;
                dec->vis.start_bit_pending = 0;
                dec->vis.buffering = 1;
                dec->vis.buf_pos = 0;
                if (dec->debug_level >= 2) {
                    fprintf(stderr, "[DECODER] Entering VIS_WAITING state\n");
                }
            } else if (dec->sync_pulse_count > 1 && dec->vis.bit_count == 0) {
                /* Subsequent syncs without VIS → image data */
                dec->sync_state = SYNC_DATA_WAIT;
            }
            
            dec->sync_state = SYNC_IDLE;
        }
        dec->sync_pulse_duration = 0;
        dec->sync_energy = 0.0;
    }
}

/**
 * Convert VIS code to SSTV mode
 * 
 * @param vis_code 8-bit VIS code (after bit accumulation)
 * @param is_extended 1 if this is an extended (16-bit) VIS code
 * @return SSTV mode or SSTV_MODE_COUNT if not found
 */
static sstv_mode_t vis_code_to_mode(uint8_t vis_code, int is_extended) {
    /* Special case: 0x23 is the prefix for extended VIS (16-bit) */
    if (!is_extended && vis_code == 0x23) {
        return SSTV_MODE_COUNT; /* Signal to expect extended VIS */
    }
    
    /* Search lookup table */
    for (size_t i = 0; i < VIS_MAP_SIZE; i++) {
        if (VIS_CODE_MAP[i].vis_code == vis_code) {
            sstv_mode_t mode = VIS_CODE_MAP[i].mode;
            
            /* Disambiguate extended codes that share same byte value */
            if (is_extended) {
                /* Extended VIS codes: MR, MP, ML, MN, MC series */
                /* These are only valid in extended mode */
                if (mode >= SSTV_MR73 && mode <= SSTV_MC180) {
                    return mode;
                }
            } else {
                /* Standard VIS codes: exclude extended-only modes */
                if (mode < SSTV_MR73 || mode > SSTV_MC180) {
                    return mode;
                }
            }
        }
    }
    
    return SSTV_MODE_COUNT; /* Not found */
}

/**
 * Try decoding VIS by sweeping phase offsets over buffered energies.
 */
static int decoder_try_vis_from_buffer(sstv_decoder_t *dec, sstv_mode_t *mode_out) {
    if (!dec || !mode_out || !dec->vis.mark_buf || !dec->vis.space_buf) {
        return 0;
    }

    const double bit_durations[] = { 0.029, 0.030, 0.031 };
    const int step = (int)(0.002 * dec->sample_rate); /* 2ms phase step */
    const int step_samples = (step > 0) ? step : 1;

    sstv_mode_t best_mode = SSTV_MODE_COUNT;
    uint8_t best_code = 0x00;
    double best_conf = 0.0;

    for (size_t bd = 0; bd < sizeof(bit_durations) / sizeof(bit_durations[0]); bd++) {
        int bit_samples = (int)(bit_durations[bd] * dec->sample_rate);
        if (bit_samples <= 0) {
            continue;
        }

        int required_samples = bit_samples * 8;
        if (dec->vis.buf_pos < required_samples) {
            continue;
        }

        for (int start_pos = 0; start_pos <= dec->vis.buf_pos - required_samples; start_pos += step_samples) {
            uint8_t data = 0x00;
            double conf = 0.0;
            int ok = 1;

            for (int bit = 0; bit < 8; bit++) {
                int start = start_pos + bit * bit_samples;
                int end = start + bit_samples;
                if (end > dec->vis.buf_pos) {
                    ok = 0;
                    break;
                }

                double sum_mark = 0.0;
                double sum_space = 0.0;
                for (int i = start; i < end; i++) {
                    sum_mark += dec->vis.mark_buf[i];
                    sum_space += dec->vis.space_buf[i];
                }

                double avg_mark = sum_mark / (double)bit_samples;
                double avg_space = sum_space / (double)bit_samples;
                double diff = avg_mark - avg_space;
                conf += fabs(diff);

                data >>= 1;
                if (diff > 0.0) {
                    data |= 0x80;
                }
            }

            if (!ok) {
                continue;
            }

            if (!vis_parity_ok(data)) {
                continue;
            }
            sstv_mode_t mode = vis_code_to_mode(data, 0);
            if (mode != SSTV_MODE_COUNT && conf > best_conf) {
                best_mode = mode;
                best_code = data;
                best_conf = conf;
            }
        }
    }

    if (best_mode != SSTV_MODE_COUNT) {
        dec->vis.data = best_code;
        dec->vis.bit_count = 8;
        *mode_out = best_mode;
        if (dec->debug_level >= 2) {
            fprintf(stderr, "[DECODER] VIS decoded (buffered): 0x%02x → mode %d\n", best_code, best_mode);
        }
        return 1;
    }

    return 0;
}

static int vis_parity_ok(uint8_t vis_code) {
    uint8_t data = vis_code & 0x7F;
    int parity = (vis_code >> 7) & 1;
    int ones = 0;
    for (int i = 0; i < 7; i++) {
        if (data & (1u << i)) {
            ones++;
        }
    }
    return (ones % 2) == parity;
}

/**
 * Check if VIS has been fully decoded and extract mode
 * 
 * @param dec Decoder handle
 * @param mode_out Output: detected mode (if return value is 1)
 * @return 1 if VIS ready and mode detected, 0 otherwise
 */
static int decoder_check_vis_ready(sstv_decoder_t *dec, sstv_mode_t *mode_out) {
    if (!dec || !mode_out) return 0;
    
    /* Check if VIS decoding is complete */
    if (dec->sync_state != SYNC_VIS_DECODING) {
        return 0; /* Not in VIS decoding state */
    }
    
    /* Check if we have accumulated enough bits */
    if (dec->vis.is_16bit) {
        /* 16-bit extended VIS: need all 16 bits */
        if (dec->vis.bit_count < 16) {
            return 0;
        }
    } else {
        /* 7-bit standard VIS + 1 parity bit = 8 bits total */
        if (dec->vis.bit_count < 8) {
            return 0;
        }
    }
    
    /* Extract VIS code from accumulated bits */
    uint8_t vis_code = dec->vis.data & 0xFF;

    if (dec->debug_level >= 3) {
        fprintf(stderr, "[DECODER] VIS code extracted: 0x%02x\n", vis_code);
    }
    
    /* Check if this is the extended VIS prefix */
    if (!dec->vis.is_16bit && vis_code == 0x23) {
        /* Switch to 16-bit mode, expect 8 more bits */
        dec->vis.is_16bit = 1;
        dec->vis.bit_count = 0;
        dec->vis.data = 0;
        return 0; /* Wait for extended code */
    }
    
    /* For extended VIS, extract second byte */
    if (dec->vis.is_16bit) {
        vis_code = (dec->vis.data >> 8) & 0xFF;
    }
    
    /* Convert VIS code to mode */
    sstv_mode_t mode = vis_code_to_mode(vis_code, dec->vis.is_16bit);
    
    if (mode == SSTV_MODE_COUNT) {
        /* Unknown VIS code */
        if (dec->debug_level >= 1) {
            fprintf(stderr, "[DECODER] Unknown VIS code: 0x%02x %s\n", 
                    vis_code, dec->vis.is_16bit ? "(extended)" : "(standard)");
        }
        return 0;
    }
    
    /* Valid mode detected */
    *mode_out = mode;
    dec->detected_mode = mode;  /* Store in decoder state */
    
    if (dec->debug_level >= 2) {
        fprintf(stderr, "[DECODER] VIS decoded: 0x%02x → mode %d (%s)\n", 
                vis_code, mode, dec->vis.is_16bit ? "extended" : "standard");
    }
    
    /* Move to data wait state */
    dec->sync_state = SYNC_DATA_WAIT;
    
    return 1; /* VIS ready and mode detected */
}

void sstv_decoder_set_mode_hint(sstv_decoder_t *dec, sstv_mode_t mode) {
    if (!dec) return;
    dec->mode_hint = mode;
}

void sstv_decoder_set_vis_enabled(sstv_decoder_t *dec, int enable) {
    if (!dec) return;
    dec->vis_enabled = enable ? 1 : 0;
}

void sstv_decoder_set_vis_tones(sstv_decoder_t *dec, double mark_hz, double space_hz) {
    if (!dec) return;
    if (mark_hz <= 0.0 || space_hz <= 0.0) return;
    dec->iir_mark.SetFreq(mark_hz, dec->sample_rate, 10.0);
    dec->iir_space.SetFreq(space_hz, dec->sample_rate, 10.0);
}

sstv_rx_status_t sstv_decoder_feed(
    sstv_decoder_t *dec,
    const float *samples,
    size_t sample_count
) {
    if (!dec || !samples || sample_count == 0) {
        return SSTV_RX_ERROR;
    }

    /* Process each sample through demod pipeline */
    for (size_t i = 0; i < sample_count; i++) {
        double sample = (double)samples[i];
        decoder_process_sample(dec, sample);
    }

    /* Check VIS readiness */
    sstv_mode_t detected_mode;
    if (decoder_check_vis_ready(dec, &detected_mode)) {
        dec->last_status = SSTV_RX_IMAGE_READY;
        return SSTV_RX_IMAGE_READY;
    }

    /* Still accumulating data */
    dec->last_status = SSTV_RX_NEED_MORE;
    return SSTV_RX_NEED_MORE;
}

int sstv_decoder_get_image(sstv_decoder_t *dec, sstv_image_t *out_image) {
    if (!dec || !out_image) {
        return -1;
    }
    return -1;
}

int sstv_decoder_get_state(sstv_decoder_t *dec, sstv_decoder_state_t *state) {
    if (!dec || !state) {
        return -1;
    }
    
    /* Return detected mode if VIS has been decoded, otherwise return hint */
    state->current_mode = (dec->detected_mode != SSTV_MODE_COUNT) 
                          ? dec->detected_mode 
                          : dec->mode_hint;
    state->vis_enabled = dec->vis_enabled;
    state->sync_detected = (dec->sync_state != SYNC_IDLE);
    state->image_ready = (dec->last_status == SSTV_RX_IMAGE_READY);
    state->current_line = dec->image_buf.current_line;
    state->total_lines = dec->image_buf.height;
    
    return 0;
}

void sstv_decoder_set_debug_level(sstv_decoder_t *dec, int level) {
    if (!dec) return;
    dec->debug_level = level;
}

sstv_rx_status_t sstv_decoder_feed_sample(sstv_decoder_t *dec, float sample) {
    if (!dec) return SSTV_RX_ERROR;
    return sstv_decoder_feed(dec, &sample, 1);
}
